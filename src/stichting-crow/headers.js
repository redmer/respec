// @ts-check
// Module stichting-crow/headers
// Generate the headers material based on the provided configuration.
// CONFIGURATION
//  - specStatus: the short code for the specification's level level or type (required)
//  - shortName: the small name that is used after /TR/ in published reports (required)
//  - editors: an array of people editing the document (at least one is required). People
//      are defined using:
//          - name: the person's name (required)
//          - url: URI for the person's home page
//          - company: the person's company
//          - companyURL: the URI for the person's company
//          - mailto: the person's email
//          - note: a note on the person (e.g. former editor)
//  - authors: an array of people who are contributing authors of the document.
//  - formerEditors: an array of people that had earlier edited the document but no longer edit.
//  - subtitle: a subtitle for the specification
//  - publishDate: the date to use for the publication, default to document.lastModified, and
//      failing that to now. The format is YYYY-MM-DD or a Date object.
//  - previousPublishDate: the date on which the previous version was published.
//  - previous} , Maturity: the specStatus of the previous version
//  - errata: the URI of the errata document, if any
//  - alternateFormats: a list of alternate formats for the document, each of which being
//      defined by:
//          - uri: the URI to the alternate
//          - label: a label for the alternate
//          - lang: optional language
//          - type: optional MIME type
//  - logos: a list of logos to use instead of the W3C logo, each of which being defined by:
//          - src: the URI to the logo (target of <img src=>)
//          - alt: alternate text for the image (<img alt=>), defaults to "Logo" or "Logo 1", "Logo 2", ...
//            if src is not specified, this is the text of the "logo"
//          - height: optional height of the logo (<img height=>)
//          - width: optional width of the logo (<img width=>)
//          - url: the URI to the organization represented by the logo (target of <a href=>)
//          - id: optional id for the logo, permits custom CSS (wraps logo in <span id=>)
//          - each logo element must specify either src or alt
//  - testSuiteURI: the URI to the test suite, if any
//  - implementationReportURI: the URI to the implementation report, if any
//  - noRecTrack: set to true if this document is not intended to be on the Recommendation track
//  - edDraftURI: the URI of the Editor's Draft for this document, if any. Required if
//      specStatus is set to "ED".
//  - additionalCopyrightHolders: a copyright owner in addition to W3C (or the only one if specStatus
//      is unofficial)
//  - copyrightStart: the year from which the copyright starts running
//  - prevED: the URI of the previous Editor's Draft if it has moved
//  - prevRecShortname: the short name of the previous Recommendation, if the name has changed
//  - prevRecURI: the URI of the previous Recommendation if not directly generated from
//    prevRecShortname.
//  - wg: the name of the WG in charge of the document. This may be an array in which case wgURI
//      and wgPatentURI need to be arrays as well, of the same length and in the same order
//  - wgURI: the URI to the group's page, or an array of such
//  - wgPatentURI: the URI to the group's patent information page, or an array of such. NOTE: this
//      is VERY IMPORTANT information to provide and get right, do not just paste this without checking
//      that you're doing it right
//  - wgPublicList: the name of the mailing list where discussion takes place. Note that this cannot
//      be an array as it is assumed that there is a single list to discuss the document, even if it
//      is handled by multiple groups
//  - charterDisclosureURI: used for IGs (when publishing IG-NOTEs) to provide a link to the IPR commitment
//      defined in their charter.
//  - thisVersion: the URI to the dated current version of the specification. ONLY ever use this for CG/BG
//      documents, for all others it is autogenerated.
//  - latestVersion: the URI to the latest version of the specification.
//  - prevVersion: the URI to the previous (dated) version of the specification. ONLY ever use this for CG/BG
//      documents, for all others it is autogenerated.
//  - subjectPrefix: the string that is expected to be used as a subject prefix when posting to the mailing
//      list of the group.
//  - otherLinks: an array of other links that you might want in the header (e.g., link github, twitter, etc).
//         Example of usage: [{key: "foo", href:"https://b"}, {key: "bar", href:"https://"}].
//         Allowed values are:
//          - key: the key for the <dt> (e.g., "Bug Tracker"). Required.
//          - value: The value that will appear in the <dd> (e.g., "GitHub"). Optional.
//          - href: a URL for the value (e.g., "https://foo.com/issues"). Optional.
//          - class: a string representing CSS classes. Optional.
//  - license: can be one of the following
//      - "cc-by", which is experimentally available in some groups (but likely to be phased out).
//          Note that this is a dual licensing regime.
//      - "document", which is the old, but still available, document license.
//      - "dual", dual license.
//      - "cc0", an extremely permissive license. It is only recommended if you are working on a document that is
//          intended to be pushed to the WHATWG.
//      - "w3c-software", a permissive and attributions license (but GPL-compatible).
//      - "w3c-software-doc", (default) the W3C Software and Document License
//            https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
import { html } from "../core/import-maps.js";
import { pub } from "../core/pubsubhub.js";
import {
  codedJoinOr,
  docLink,
  htmlJoinAnd,
  ISODate,
  norm,
  showError,
  showWarning,
} from "../core/utils.js";
import headersTmpl from "./templates/headers.js";
import sotdTmpl from "./templates/sotd.js";

export const name = "stichting-crow/headers";

/**
 * Resolves against docs.crow.nl
 * @param {string} href
 * @returns URL
 */
function docsHome(href) {
  return new URL(href, "https://docs.crow.nl/").href;
}

/** @type {Map<string, SpecStatusInfo>} */
export const specStatus2info = new Map(
  /** @type {SpecStatusInfo[]} */
  [
    {
      id: "LD",
      name: "living document",
      name_nl: "levend document",
      hex: "#009de0",
    },
    {
      id: "IR",
      name: "in review",
      name_nl: "referentieversie",
      hex: "#007e84",
    },
    {
      id: "DRAFT",
      name: "draft document",
      name_nl: "werkdocument",
      hex: "#409D69",
    },
    { id: "DOC", name: "document", name_nl: "document", hex: "#DEE4E9" },
    { id: "REG", name: "registry", name_nl: "register", hex: "#DEE4E9" },
    {
      id: "PFB",
      name: "project description",
      name_nl: "projectbeschrijving",
      level: 0,
      hex: "#a1c036",
    },
    {
      id: "NP",
      name: "project proposal",
      name_nl: "projectvoorstel",
      level: 10,
      hex: "#a1c036",
    },
    {
      id: "WD",
      name: "working draft",
      name_nl: "werkconcept",
      level: 20,
      hex: "#409d69",
    },
    {
      id: "CR",
      name: "committee review",
      name_nl: "in consultatie",
      level: 30,
      hex: "#007e84",
    },
    {
      id: "PR",
      name: "public review",
      name_nl: "ter vaststelling",
      level: 40,
      hex: "#007e84",
    },
    {
      id: "OR",
      name: "open review",
      name_nl: "tervisielegging",
      level: 50,
      hex: "#007e84",
    },
    {
      id: "DEF",
      name: "approved",
      name_nl: "vastgesteld",
      level: 60,
      hex: "#009de0",
    },
    {
      id: "REPL",
      name: "superceded",
      name_nl: "vervangen",
      level: 95,
      hex: "#ff6e1a",
    },
    {
      id: "RESC",
      name: "rescinded",
      name_nl: "teruggetrokken",
      level: 95,
      hex: "#ff6e1a",
    },
    {
      id: "RQR",
      name: "requires review",
      name_nl: "niet onderhouden",
      level: 90,
      hex: "#6e6e6e",
    },
  ].map(info => [info.id, info])
);

/** @type {Map<string, LicenseInfo>} */
export const licenses = new Map([
  [
    "cc0",
    {
      name: "Creative Commons 0 Public Domain Dedication",
      name_nl: "Creative Commons 0 Publiekdomeinverklaring",
      short: "CC0",
      url: "https://creativecommons.org/publicdomain/zero/1.0/",
    },
  ],
  [
    "cc-by",
    {
      name: "Creative Commons Attribution",
      name_nl: "Creative Commons Naamsvermelding",
      short: "CC BY 4.0",
      url: "https://creativecommons.org/licenses/by/4.0/",
    },
  ],
  [
    "cc-by-sa",
    {
      name: "Creative Commons Attribution-ShareAlike",
      name_nl: "Creative Commons Naamsvermelding-GelijkDelen",
      short: "CC BY-SA 4.0",
      url: "https://creativecommons.org/licenses/by-sa/4.0/",
    },
  ],
  [
    undefined,
    {
      name: "unlicensed",
      name_nl: "unlicensed",
      url: null,
      short: "UNLICENSED",
    },
  ],
]);

/**
 * Format a date.
 *
 * @param {*} conf
 * @param {string} prop
 * @param {string | number | Date} fallbackDate
 */
function validateDateAndRecover(conf, prop, fallbackDate = new Date()) {
  const date = conf[prop] ? new Date(conf[prop]) : new Date(fallbackDate);
  // if date is valid
  if (Number.isFinite(date.valueOf())) {
    const formattedDate = ISODate.format(date);
    return new Date(formattedDate);
  }
  const msg = docLink`${prop} is not a valid date: "${conf[prop]}". Expected format 'YYYY-MM-DD'.`;
  showError(msg, name);
  return new Date(ISODate.format(new Date()));
}

/**
 * Get license info.
 *
 * @param {*} conf
 * @returns {LicenseInfo}
 */
function deriveLicenseInfo(conf) {
  let license = undefined;
  //* Setting conf.license
  if (typeof conf.license === "string") {
    const lCaseLicense = conf.license.toLowerCase();
    if (!licenses.has(lCaseLicense)) {
      const msg = `The license "\`${conf.license}\`" is not supported.`;
      const choices = codedJoinOr(
        [...licenses.keys()].filter(k => k),
        {
          quotes: true,
        }
      );
      const hint = docLink`Please set
        ${"[license]"} to one of: ${choices}. If in doubt, remove \`license\` and let ReSpec pick one for you.`;
      showError(msg, name, { hint });
    } else {
      license = lCaseLicense;
    }
  }

  const licenseInfo = licenses.get(license);
  return licenseInfo;
}

/**
 * Get SpecStatus info.
 *
 * @param {*} conf
 * @returns {SpecStatusInfo}
 */
function deriveSpecStatusInfo(conf) {
  let specStatus = undefined;
  //* Setting conf.specStatus
  if (typeof conf.specStatus === "string") {
    const uCaseSpecStatus = conf.specStatus; //. toUpperCase();
    if (!specStatus2info.has(uCaseSpecStatus)) {
      const msg = `The specStatus "\`${conf.specStatus}\`" is not supported.`;
      const choices = codedJoinOr(
        [...specStatus2info.keys()].filter(k => k),
        {
          quotes: true,
        }
      );
      const hint = docLink`Please set
        ${"[specStatus]"} to one of: ${choices}. If in doubt, remove \`specStatus\` and let ReSpec pick one for you.`;
      showError(msg, name, { hint });
    } else {
      specStatus = uCaseSpecStatus;
    }
  }

  const licenseInfo = specStatus2info.get(specStatus);
  return licenseInfo;
}

/**
 *
 * @param {Conf} conf
 */
export async function run(conf) {
  conf.specStatusInfo = deriveSpecStatusInfo(conf);
  conf.licenseInfo = deriveLicenseInfo(conf);

  //* Setting conf.shortName
  if (!conf.shortName.includes("/")) {
    const msg = docLink`The ${"[shortName]"} configuration option is required as \`"pubDomain/shortName"\`.`;
    const hint = docLink`Please set ${"[shortName]"} to a short name for the specification. E.g. "imbor/im".`;
    showError(msg, name, { hint });
  }

  conf.subjectPrefix = conf.subjectPrefix ?? `[${conf.shortName}] `;
  conf.isInReview =
    conf.isInReview || ["CR", "PR", "OR", "IR"].includes(conf.specStatus);

  //* Setting conf.publishDate
  conf.publishDate = validateDateAndRecover(
    conf,
    "publishDate",
    document.lastModified
  );
  //* Setting conf.publishYear
  conf.publishYear = conf.publishDate.getUTCFullYear();
  //* Setting conf.modificationDate
  if (conf.modificationDate) {
    conf.modificationDate = validateDateAndRecover(
      conf,
      "modificationDate",
      document.lastModified
    );
  }

  //* - Version URIs

  //* Setting conf.edDraftURI | URL of the GitHub Pages draft document
  // edDraftURI is set by github.js
  conf.edDraftURI = docsHome(conf.shortName);
  //* Setting conf.thisVersion | URL of the current document
  //* Setting conf.latestVersion | URL of the latest DEF/DOC version
  //* Setting conf.prevVersion | URL of the previous maturity version
  // latestVersion, thisVersion, prevVersion set by publishing script

  // Move any editors with retiredDate to formerEditors.
  for (let i = 0; i < conf.editors.length; i++) {
    const editor = conf.editors[i];
    if ("retiredDate" in editor) {
      conf.formerEditors.push(editor);
      conf.editors.splice(i--, 1);
    }
  }

  //* Setting conf.editors | List of editors.
  if (conf.editors.length === 0) {
    const msg = "At least one editor is required.";
    const hint = docLink`Add one or more editors using the ${"[editors]"} configuration option.`;
    showError(msg, name, { hint });
  }

  if (conf.alternateFormats?.some(({ uri, label }) => !uri || !label)) {
    const msg = docLink`Every ${"[`alternateFormats`]"} entry must have a \`uri\` and a \`label\`.`;
    showError(msg, name);
  }
  if (conf.copyrightStart == conf.publishYear) conf.copyrightStart = "";

  //* Dates

  //* Setting conf.publishDate | Date of publishing.
  conf.dashDate = ISODate.format(conf.publishDate);
  conf.publishISODate = conf.publishDate.toISOString();
  conf.shortISODate = ISODate.format(conf.publishDate);

  if (conf.reviewDateEnd) {
    conf.reviewDateEnd = validateDateAndRecover(conf, "reviewDateEnd");
  }

  //* Setting conf.historyURI | If history listing of this spec resides somewhere else.
  // conf.historyURI = docsHome(`${conf.shortName}/versions`);
  // configuration done - yay!

  const options = {
    get multipleAlternates() {
      return conf.alternateFormats && conf.alternateFormats.length > 1;
    },
    get alternatesHTML() {
      return (
        conf.alternateFormats &&
        htmlJoinAnd(
          // We need to pass a string here...
          conf.alternateFormats.map(({ label }) => label),
          (_, i) => {
            const alt = conf.alternateFormats[i];
            return html`<a
              rel="alternate"
              href="${alt.uri}"
              hreflang="${alt?.lang ?? null}"
              type="${alt?.type ?? null}"
              >${alt.label}</a
            >`;
          }
        )
      );
    },
  };

  // insert into document
  const header = headersTmpl(conf, options);
  document.body.prepend(header);
  document.body.classList.add("h-entry");

  // handle SotD
  const sotd =
    document.getElementById("sotd") || document.createElement("section");
  if (conf.specStatusInfo.level > 0 && !sotd.id) {
    const msg =
      "A Status of This Document must include at least on custom paragraph.";
    const hint =
      "Add a `<p>` in the 'sotd' section that reflects the status of this specification.";
    showError(msg, name, { elements: [sotd], hint });
  }
  sotd.id = sotd.id || "sotd";
  sotd.classList.add("introductory");

  if (!sotd.classList.contains("override")) {
    html.bind(sotd)`${populateSoTD(conf, sotd)}`;
  }

  configCheck(conf);

  // Requested by https://github.com/w3c/respec/issues/504
  // Makes a record of a few auto-generated things.
  pub("amend-user-config", {
    publishISODate: conf.publishISODate,
    generatedSubtitle: norm(
      document.getElementById("w3c-state")?.textContent ?? ""
    ),
  });
}

/**
 *
 * @param {Conf} conf
 * @returns
 */
function configCheck(conf) {
  if (conf.isInReview && !conf.reviewDateEnd) {
    const msg = docLink`${"[specStatus]"} is reviewable no ${"[reviewDateEnd]"} is specified in the ${"[respecConfig]"}.`;
    showError(msg, name);
  }
  // conf.updateableRec = sotd.classList.contains("updateable-rec");
  // const revisionTypes = ["addition", "correction"];
  // if (conf.isRec && conf.revisionTypes?.length > 0) {
  //   if (conf.revisionTypes.some(x => !revisionTypes.includes(x))) {
  //     const unknownRevisionTypes = conf.revisionTypes.filter(
  //       x => !revisionTypes.includes(x)
  //     );
  //     const msg = docLink`${"[specStatus]"} is "${
  //       conf.specStatus
  //     }" with unknown ${"[revisionTypes]"}: '${codedJoinOr(
  //       unknownRevisionTypes
  //     )}'.`;
  //     const hint = docLink`The valid values for ${"[revisionTypes]"} are: ${codedJoinOr(
  //       revisionTypes
  //     )}.`;
  //     showError(msg, name, { hint });
  //   }
  //   if (conf.revisionTypes.includes("addition") && !conf.updateableRec) {
  //     const msg = docLink`${"[specStatus]"} is "${
  //       conf.specStatus
  //     }" with proposed additions but the ${
  //       conf.specStatusInfo.name
  //     } is not marked as a allowing new features.`;
  //     showError(msg, name);
  //   }
  // }
}

/**
 * Populate Status of This Document information.
 *
 * Adds mailto-url, subject-prefix,
 * @param {*} conf
 * @param {HTMLElement} sotd
 */
function populateSoTD(conf, sotd) {
  const options = {
    ...collectSotdContent(sotd, conf),

    get mailtoEmailComments() {
      return `mailto:${conf.emailComments}`;
    },
    get subjectPrefix() {
      return `[${conf.shortName}] `;
    },
    get mailtoEmailCommentsWithSubject() {
      const fragment = conf.shortName
        ? `?subject=${encodeURIComponent(this.subjectPrefix)}%20`
        : "";
      return this.mailtoEmailComments + fragment;
    },
  };
  const template = sotdTmpl;
  return template(conf, options);
}

/**
 * @param {HTMLElement} sotd
 */
function collectSotdContent(sotd, { isTagFinding = false }) {
  const sotdClone = sotd.cloneNode(true);
  const additionalContent = document.createDocumentFragment();
  // we collect everything until we hit a section,
  // that becomes the custom content.
  while (sotdClone.hasChildNodes()) {
    if (
      sotdClone.nodeType === Node.ELEMENT_NODE &&
      // @ts-ignore
      sotdClone.firstChild.localName === "section"
    ) {
      break;
    }
    additionalContent.appendChild(sotdClone.firstChild);
  }
  if (isTagFinding && !additionalContent.hasChildNodes()) {
    const msg = docLink`ReSpec does not support automated SotD generation for TAG findings.`;
    const hint = `Please add the prerequisite content in the 'sotd' section.`;
    showWarning(msg, name, { hint });
  }
  return {
    additionalContent,
    // Whatever sections are left, we throw at the end.
    additionalSections: sotdClone.childNodes,
  };
}
